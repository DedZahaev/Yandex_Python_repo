n = int(input())

s = 0
k = 0
l_max = 1 # для подсчета от 1 до длины просто имхо 1 чтобы с 1 считалась до максимальной длины строки
while k < n: # бесконечный цикл пока не дойдет до последнего числа
    s += 1 # тут количество шагов как я понял
    k += s # тут хуй знает как эта к работает но она для правильного подсчета в цикле , тоже типа составная формулы
    length = 0 # всегда обнуляется , чтобы подсчитать максимальную строчку от которой будет зависеть ширина елки вроде бы
    for i in range(k - s + 1, k + 1):        # тут цикл короче который правильно считается по формуле
        length += len(str(i)) + 1    # тут короче длина всей строки с пробелами как я понял
        if i == n:  # тут цикл завершается потому что дошла до ласт числа  
            break
    l_max = max(l_max, length - 1) # тупа подсчет поеботы в виде макс длины строки елки - 1 потому что ласт пробел убираем
print(l_max)
    # блять короче второй цикл нужен уже для вывода самой елки пиздец

s = 0
k = 0

while k < n: # ща ебанем отладку и проверем вторую поеботу (вроде плюс минус понял алгоритм решения (ебать задача нахуй))
    t = '' # блять че просто поставил переменную на место хорош
    s += 1 # тут нехуй объяснять второй раз
    k += s  # тут нехуй объяснять второй раз
    for i in range(k - s + 1, k + 1): # ебаный второй цикл
        t += str(i) # тут прибавляет цифору в строке 
        if i == n: # тут нехуй объяснять второй раз
            break
        t += ' ' # тут пробел после кажой цифры
    print(f'{t:^{l_max + 1}}') # ебать вывод через ф строки :^ эта хуйня это центрирование как center() по Лмаксу + 1
                               # то что идет после центрирование это значение по которому центрирует {l_max + 1}} 
                               # центрирует он по максимальной длинне строки из первого цикла тоесть самой елки вот
                               # + 1 потому что центрирует по пробелам слева и справа чтобы получилось точно нужно прибавлять еженицу